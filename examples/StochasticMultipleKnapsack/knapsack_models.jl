### Compact two-stage formulation of the problem
###  Most of the code was generated by ChatGPT

using JuMP


# -------------------------
# Construct your instance
# -------------------------

"""
    compact_two_stage_from_file(path::AbstractString)

Generate and return a compact two stage formulation form passed cor and sto files of stochastic multiple knapsack instances. 
"""
function compact_two_stage_from_file(path_cor::AbstractString, path_sto::AbstractString)
    # read in master structure
    kn_master = read_knapsack_mps_to_model(path_cor)
    scenarios = read_q_scenarios(path_sto)

    # for debuging add a variable that respresents first-stage objective
    add_first_stage_obj_variable(kn_master)

    # add second level constraints
    compact_two_stage(kn_master, scenarios, kn_master.x_vars)
    return kn_master.my_model
end

"""
    compact_two_stage_from_file_neg(path::AbstractString)

Generate and return a compact two stage formulation from passed cor and sto files of stochastic multiple knapsack instances. 
However, we now use inverse x variables, i.e., their negation, to link first and second stage
"""
function compact_two_stage_from_file_neg(path_cor::AbstractString, path_sto::AbstractString)
    # read in master structure
    kn_master = read_knapsack_mps_to_model(path_cor)
    scenarios = read_q_scenarios(path_sto)

    # for debuging add a variable that respresents first-stage objective
    add_first_stage_obj_variable(kn_master)

    # add negative x-variables to master
    xneg = add_negated_x_vars(kn_master)

    # add second level constraints
    xneg_epressions = Dict{String, Any}(xn => 1-xne for (xn, xne) in xneg)
    compact_two_stage(kn_master, scenarios, xneg_epressions)
    return kn_master.my_model
end


"""
    two_stage_JuBiC(path_cor::AbstractString, path_sto::AbstractString)

Generate a two stage formulation for the GBCSolver that solves the stochastic multiple knapsack for instance given by passed cor and sto files

"""
function two_stage_JuBiC(path_cor::AbstractString, path_sto::AbstractString, solver::SolverWrapper; partial_dec=true)::JuBiC.Instance
    # read in master structure
    kn_master = read_knapsack_mps_to_model(path_cor)
    scenarios = read_q_scenarios(path_sto)

    # for debuging add a variable that respresents first-stage objective
    add_first_stage_obj_variable(kn_master)

    # add negative x-variables to master
    ## Negative variables make no sense: The way the covering problem is formulated, you gain an advantage if you can use the first-level variables

    # partial decomposition
    if partial_dec
        add_feasibility_subproblem_constraints(kn_master.my_model, kn_master.info_second_stage, kn_master.x_vars)
    end

    # build master instance
    master = Master(kn_master.my_model, collect(keys(kn_master.x_vars)), kn_master.x_vars, string.(collect(keys(scenarios))))

    # now build the subproblems
    saved = kn_master.info_second_stage
    q_names = sort!(collect(Set(Iterators.flatten(keys(info.q) for info in values(saved)))))
    subproblems = []
    for (s, scen) in enumerate(scenarios)
        # create subproblem MIP
        submodel_s = Model()
        set_optimizer(submodel_s, () -> get_next_optimizer(solver))
        set_silent(submodel_s) 

        # add subproblem original variables and constraints 
        @variable(submodel_s, xcopy[keys(kn_master.x_vars)], Bin) # copies of x-variables from first stage
        @variable(submodel_s, xsub[keys(kn_master.x_vars)], Bin) # subproblem x-variables used in constraints

        xsub_expr = Dict(nx => xsub[nx] for nx in collect(keys(kn_master.x_vars)))
        q_s, constr, obj = add_scenario_specific_constraints!(submodel_s, saved, q_names, s, scen, xsub_expr)
        @objective(submodel_s, Min, 0.05*obj) # rescale by scenario probability

        # add linking constraints for negated variables
        for (nx, xv) in kn_master.x_vars
            @constraint(submodel_s, xsub[nx] <= xcopy[nx], base_name="sublink_$(nx)")
        end

        # build subproblem instance
        link_constraints_capacities = Dict(a => 1.0 for a in keys(kn_master.x_vars))
        sub_instance = SubSolverJuMP(
            string(s),
            submodel_s,
            collect(keys(kn_master.x_vars)),
            xcopy,
            xsub,
            link_constraints_capacities,
            obj, # first level obj
            obj, # =second-level obj 
            time -> (false, 0)
        )

        # finished
        push!(subproblems, sub_instance)
    end

    rV = Instance(master, subproblems)
    return rV
end









# -------------------------
# Auxiliary functions
# -------------------------

function add_first_stage_obj_variable(kn_master::Knapcksack_Master)
    current_obj = objective_function(kn_master.my_model)
    @variable(kn_master.my_model, OBJ_FS)
    @constraint(kn_master.my_model, current_obj == OBJ_FS, base_name="L1_Obj")
end

"""
    add_negated_x_vars(kn_master::Knapcksack_Master)::Dict{String, JuMP.VariableRef}

Add negations of x-variables to master and return the new generated variables as name->var mapping
"""
function add_negated_x_vars(kn_master::Knapcksack_Master)::Dict{String, JuMP.VariableRef}
    # add variables
    xneg = Dict{String, JuMP.VariableRef}()
    for (xn, x) in kn_master.x_vars
        xnegative = @variable(kn_master.my_model, binary = true, base_name = "$(xn)_neg")
        xneg[xn] = xnegative
    end

    # link negative variables with original ones
    for (xn, x) in kn_master.x_vars
        @constraint(kn_master.my_model, xneg[xn] == 1-x, base_name="link_$(xn)")
    end
    return xneg
end




"""
    compact_two_stage(kn_master::Knapcksack_Master)

Transform the MIP in the passed 'Knapcksack_Master' master instance into a compact two-stage model.
"""
function compact_two_stage(kn_master::Knapcksack_Master, scenarios::Vector{Dict{String,Float64}}, x_expression::Dict)
    # add second stage constraints
    twostage = kn_master.my_model
    nq_vars, constr, objs = add_scenario_constraints!(twostage, kn_master.info_second_stage, scenarios, x_expression)

    # adjust objective into two stage setting
    twostageobj = objective_function(kn_master.my_model)
    @variable(twostage, sigma[collect(keys(objs))])
    for (s, obj) in objs
        @constraint(twostage, sigma[s] == 0.05*obj, base_name="objSS$s")
        add_to_expression!(twostageobj, sigma[s])
    end
    @objective(kn_master.my_model, Min, twostageobj)
end


"""
add_scenario_constraints!(model, saved, scenarios; x_vars)

- saved: Dict("c51" => (sense, rhs, q::Dict, x::Dict), ...)
- scenarios: Vector{Dict{String,Float64}}  # per scenario: qname => value
- x_vars: Dict    # existing x* vars by name. You can pass any expression instead of x-variables and it will be used instead

Returns (q_vars, constrs):
  q_vars[s][qname]  -> VariableRef fixed to scenario s's value
  constrs[s][cname] -> ConstraintRef for cname in scenario s (named "cname_s<s>")
"""
function add_scenario_constraints!(model::JuMP.Model,
                                   saved::Dict{String,<:NamedTuple},
                                   scenarios::Vector{Dict{String,Float64}},
                                   x_vars::Dict)

    # All q names that appear in the saved constraints
    q_names = sort!(collect(Set(Iterators.flatten(keys(info.q) for info in values(saved)))))

    q_vars  = Dict{Int, Dict{String,JuMP.VariableRef}}()
    constrs = Dict{Int, Dict{String,JuMP.ConstraintRef}}()
    objs = Dict{Int, JuMP.AffExpr}()

    for (s, scen) in enumerate(scenarios)
        q_s, constr, obj = add_scenario_specific_constraints!(model, saved, q_names, s, scen, x_vars)
        q_vars[s] = q_s
        constrs[s] = constr
        objs[s] = obj
    end

    return q_vars, constrs, objs
end

"""
    add_scenario_specific_constraints!(model::JuMP.Model, saved_constraints::Dict{String,<:NamedTuple}, q_names::Vector{String}, scenario::Dict{String,Float64}, x_vars::Dict)

A subroutine of 'add_scenario_constraints!' that generates variables and constraints for a given scenario.

    - 'model::JuMP.Model': The MIP we should add the variables and constraints to. 
    - 'saved_constraints::Dict{String,<:NamedTuple}': The constraints recovered from the mps-file that should be added to the subproblem.
    - 'q_names::Vector{String}': The names of the second stage q variables. 
    - 's': Scenario name.
    - 'scenario::Dict{String,Float64}': The specific scenario, given as a mapping of q-variable name to objective value for subproblem. 
    - 'x_vars::Dict': A mapping of original x-variable name to expression that should be used within the constraint in the subproblem now
"""
function add_scenario_specific_constraints!(model::JuMP.Model, saved_constraints::Dict{String,<:NamedTuple}, q_names::Vector{String}, s, scenario::Dict{String,Float64}, x_vars::Dict)
    # 1) Make q_s variables and fix them to the scenario values
    q_s = Dict{String,JuMP.VariableRef}()
    for qn in q_names
        v = @variable(model, binary = true, base_name = "$(qn)_s$(s)")
        q_s[qn] = v
    end

    # 2) Rebuild each saved constraint and objective for this scenario
    cs = Dict{String,JuMP.ConstraintRef}()
    for (cname, info) in saved_constraints
        expr = zero(AffExpr)
        for (qn, coef) in info.q
            expr += coef * q_s[qn]
        end
        for (xn, coef) in info.x
            expr += coef * x_vars[xn]
        end

        cname_s = "$(cname)_s$(s)"
        cs[cname_s] = info.sense == "<=" ? @constraint(model, expr <= info.rhs, base_name=cname_s) :
                       info.sense == ">=" ? @constraint(model, expr >= info.rhs, base_name=cname_s) :
                                            @constraint(model, expr == info.rhs, base_name=cname_s)
    end

    # construct scenario objective
    expr = zero(AffExpr)
    for (qn, val) in scenario
        add_to_expression!(expr, val * q_s[qn])
    end

    return q_s, cs, expr
end

"""
    add_feasibility_subproblem_constraints(model::JuMP.Model, saved_constraints::Dict{String,<:NamedTuple}, x_vars::Dict)

Add five constraints ensuring feasibility of subproblems to the master problem. As all subproblems use same set of constraints, 
so we just add constraints for one scenario and assume all seconds stage variables are 1, i.e., we pay maximum penalty.
    - 'model::JuMP.Model': The MIP we add constraints to.
    - 'saved_constraints::Dict{String,<:NamedTuple}' The saved constraints for an arbitary scenario
    - 'x_vars::Dict': A mapping of original x-variable name to expression that should be used within the constraint in the subproblem now
"""
function add_feasibility_subproblem_constraints(model::JuMP.Model, saved_constraints::Dict{String,<:NamedTuple}, x_vars::Dict)
    for (cname, info) in saved_constraints
        expr = zero(AffExpr)
        constant_q = 0
        for (qn, coef) in info.q
            constant_q += coef * 1
        end
        for (xn, coef) in info.x
            expr += coef * x_vars[xn]
        end

        cname_s = "PD_$(cname)"
        cs = info.sense == "<=" ? @constraint(model, expr + constant_q <= info.rhs, base_name=cname_s) :
                       info.sense == ">=" ? @constraint(model, expr + constant_q >= info.rhs, base_name=cname_s) :
                                            @constraint(model, expr + constant_q == info.rhs, base_name=cname_s)
    end
end


